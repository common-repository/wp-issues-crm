<?php
/*
*
*	wic-entity-email-cron.php
*
*   this class is intended to consolidatee the wordpress cron trigger for email processes to pace requests
*   INTENDED TO SUPPORT MULTISITE INSTALLATIONS 
*
*	CURRENTLY IMPLEMENTED ONLY FOR ACTIVESYNC SEND AND RECEIVE -- 
*	DO NOT CONFIGURE UNLESS USING ACTIVESYNC FOR BOTH SEND AND RECEIVCE
*	
usage: 
(1) place the following lines in wp-config.php above the line that reads /* That's all, stop editing! Happy blogging. 

define('WP_ISSUES_CRM_USING_CENTRAL_CRON_CONTROL', true);
define('WP_ISSUES_CRM_GET_REQUEST_PAGE_SIZE', 10 ); // number of messages batched in single request for message bodies recommended value is 10 ( will get a singe page per cycle)
define('WP_ISSUES_CRM_MESSAGES_SENT_PER_ROTATION', 10 ); // number of messages that will be sent each time the user gets a turn in the rotation generated by this function
define('WP_ISSUES_CRM_CRON_CLEARANCE_SECONDS', 20 ); // safe number number of seconds that should suffice to complete a page of get or send requests
define('WP_ISSUES_CRM_CRON_INTERVAL', 120 ); // max number of seconds that this job will keep working for -- should correspond to timing of cron interval
define('WP_ISSUES_CRM_MESSAGE_SEND_DELAY', 50 ); // milliseconds to wait between send events

(2)add an additional define line below those >>>REPLACING 'some_long_random_string' WITH A 64 CHARACTER STRING OF LETTERS AND NUMBERS (AVOID SPACES AND OTHER CHARACTERS TO STAY URL SAFE)<<<<<<
define('WP_ISSUES_CRM_RUN_CRON_KEY', 'some_long_random_string'); // 64 IS ARBITRARY 

(3) set up a cron tab to trigger at your desired cron interval -- recommended starting point: 2 minutes 

(4) in that cron tab, place the following instruction
wget -q -O - http://yoursiteurl/?wp_issues_crm_run_cron_key='the_same_long_random_string_you_inserted_in_step_two' >/dev/null 2>&1

wget line explanation: -q means quiet; -O - direct all output to standard output; >dev/null means discard standard outpout; 2>&1 means also discard errors
https://www.computerhope.com/unix/wget.htm
https://stackoverflow.com/questions/10508843/what-is-dev-null-21

You may wish to also add a line to config.php limiting the size of list sends -- example to limit to 500
define('WP_ISSUES_CRM_MESSAGE_MAX_SINGLE_SEND', 500 ); 
*
*   
*/


class WIC_Entity_Email_Cron {

	// create log mail entry in the content director ( one above plugin directory)
	public static function log_mail( $message, $log_always = false ) {

		if ( ! $log_always ) {
			if ( !defined('WP_ISSUES_CRM_USING_LOG_MAIL_VERBOSE') || !WP_ISSUES_CRM_USING_LOG_MAIL_VERBOSE ) {
				return;
			}
		}

		$wp_content_directory = plugin_dir_path( __FILE__  ) . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR  . '..' . DIRECTORY_SEPARATOR ;
		$message_wrap = "\n" . '[' . date ( DATE_RSS ) . '] ' . $message;
		
		if ( ! file_put_contents ( $wp_content_directory . 'wp_issues_crm_mail_log', $message_wrap, FILE_APPEND ) ) {
			error_log ( "WIC_Entity_Email_Cron::log_mail attempted to write to mail log this message: $message ");
			error_log ( 'Location of mail log should be: ' . $wp_content_directory . DIRECTORY_SEPARATOR . 'wp_issues_crm_mail_log -- check permissions.' );	
		};
	
	}

	public static function dump_cron_settings () {
		return "\n" . 
		'WP_ISSUES_CRM_USING_CENTRAL_CRON_CONTROL = ' . WP_ISSUES_CRM_USING_CENTRAL_CRON_CONTROL .  "\n" .
		'WP_ISSUES_CRM_GET_REQUEST_PAGE_SIZE = ' . WP_ISSUES_CRM_GET_REQUEST_PAGE_SIZE .  "\n" .
		'WP_ISSUES_CRM_MESSAGES_SENT_PER_ROTATION = ' . WP_ISSUES_CRM_MESSAGES_SENT_PER_ROTATION .  "\n" .
		'WP_ISSUES_CRM_CRON_INTERVAL = ' . WP_ISSUES_CRM_CRON_INTERVAL .  "\n" .
		'WP_ISSUES_CRM_MESSAGE_SEND_DELAY = ' . WP_ISSUES_CRM_MESSAGE_SEND_DELAY .  "\n" .
		'WP_ISSUES_CRM_CRON_CLEARANCE_SECONDS = ' . WP_ISSUES_CRM_CRON_CLEARANCE_SECONDS .  "\n";
	}

	public static function check_cron_settings () {
	
		// first check that all settings required are in place.  If not, note error and die
		if ( !
			(
				defined('WP_ISSUES_CRM_USING_CENTRAL_CRON_CONTROL') && WP_ISSUES_CRM_USING_CENTRAL_CRON_CONTROL &&
				defined('WP_ISSUES_CRM_MESSAGES_SENT_PER_ROTATION' ) &&
				defined('WP_ISSUES_CRM_CRON_INTERVAL' ) &&
				defined('WP_ISSUES_CRM_RUN_CRON_KEY' ) &&
				defined('WP_ISSUES_CRM_MESSAGE_SEND_DELAY' ) &&
				defined('WP_ISSUES_CRM_CRON_CLEARANCE_SECONDS' )

			)
		) { 
			error_log ( 'WIC_Entity_Email_Cron::mail_call was invoked, but not all cron settings were in place.' . WIC_Entity_Email_Cron::dump_cron_settings() );
			die;
		}
	
	}
	
	// run the mail routines from cron
	public static function mail_call () {

		// first test all cron settings
		self::check_cron_settings();

		// next start time at very beginning before any db calls -- dictionary can get hung up if files corrupted
		$end_time = time() + WP_ISSUES_CRM_CRON_INTERVAL - WP_ISSUES_CRM_CRON_CLEARANCE_SECONDS;  // allow time for last page request to complete

		// access database to check collation
		self::log_mail ( '>>>>>Starting high plane check.<<<<<<');
		WIC_DB_Setup::check_high_plane_collation();
		if ( time() > $end_time ) {
			self::log_mail( 'Ending mail_call -- ran out of time after high plane check' . site_url() . ".\n" . self::dump_cron_settings() );
			die;
		}
		
		// access database to initialize dictionary
		self::log_mail ( '>>>>>Initializing dictionary.<<<<<<');
		WIC_Admin_Navigation::dictionary_setup (); // dictionary not installed yet in cron
		if ( time() > $end_time ) {
			self::log_mail( 'Ending mail_call -- ran out of time after initializing dictionary' . site_url() . ".\n" . self::dump_cron_settings() );
			die;
		}

		// set up connection cache
		global $wp_issues_crm_activesync_connection_cache;
		$wp_issues_crm_activesync_connection_cache = array();
		
		// construct control array of blog ids
		self::log_mail ( '>>>>> Constructing blog_id array.<<<<<<');
		$sites = get_sites();
		$blog_ids =  array();
		foreach ( $sites as $site ) {
			if ( 1 != $site->blog_id ) { // assume no mail account for primary admin blog 
				$blog_ids[] = $site->blog_id;
			}
		}
		// shuffle array for equal treatment (overruns controlled for in each process and overrun risk is not materially changed by shuffle since usually only one process overrunning)
		shuffle ( $blog_ids );
		if ( time() > $end_time ) {
			self::log_mail( 'Ending mail_call -- ran out of time after constructing blog_id array' . site_url() . ".\n" . self::dump_cron_settings() );
			die;
		}
		/*
		* loop through the array and trigger sync for each of them 
		* the sync routine is NOT in itself time limited -- so one sync could consume the whole available time of the run; hogging others from synching until done
		* can overrun into next cron run but will not proceed until prior synch complete
		*/

		foreach ( $blog_ids as $blog_id ) {
			switch_to_blog ( $blog_id );
			self::log_mail ( 'Starting sync run for ' . site_url() );
			WIC_Entity_Email_Account::route_sync();			
			self::log_mail ( 'Completed sync run for ' . site_url() );
			// check time out and do not continue to other users or start parse/deliver if over time on sync
			if ( time() > $end_time ) {
				self::log_mail( 'Ending mail_call -- ran out of time after sync run for' . site_url() . ".\n" . self::dump_cron_settings(), true );
				die;
			}
		}

		// track parse deliver cycles
		$parse_done_blogs = array();
		$deliver_done_blogs = array();
		$count_cycling_blogs = count ( $blog_ids );
		/*
		*
		* true returns from parse and deliver mean done -- don't come back
		*
		*/
		// continue looping through pages until all done or out of time, checking time after each operation
		while ( 
			( count( $parse_done_blogs) < $count_cycling_blogs ) || 
			( count( $deliver_done_blogs ) < $count_cycling_blogs ) 
			){
			// loop the array and trigger a parse block and a send block for each mailings
			foreach ( $blog_ids as $blog_id ) {

				// looping through all blogs 
				switch_to_blog ( $blog_id );

				if ( ! in_array ( $blog_id, $parse_done_blogs ) ) {
					self::log_mail ( 'Starting parse run for ' . site_url() );
					$result = WIC_Entity_Email_Account::route_parse();			
					if ( $result ) {
						$parse_done_blogs[] = $blog_id;
					}
				}
				if ( time() > $end_time ) {
					self::log_mail( 'Ending mail_call -- ran out of time after parsing for' . site_url() . self::dump_cron_settings() );
					break(2);
				}

				if ( ! in_array ( $blog_id, $deliver_done_blogs ) ) {			
					self::log_mail ( 'Starting deliver run for ' . site_url() );
					$result = WIC_Entity_Email_Account::route_deliver();
					if ( $result ) {
						$deliver_done_blogs[] = $blog_id;
					}
				}			
				if ( time() > $end_time ) {
					self::log_mail( 'Ending mail_call -- ran out of time after delivery for' . site_url() . self::dump_cron_settings() );
					break(2);
				}
			} // close for loop	
		} // close while loop

		// cleanup		
		self::log_mail ( '>>>>>Completed mail_call in alloted time.' );
		unset ( $wp_issues_crm_activesync_connection_cache );
		die;	
	}
} // close class